# -*- coding: utf-8 -*-
"""Line graphs, hamiltonian paths and eulerian paths.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oRSVVNc4uG-0Yi_ils7MwUUmswyUVh4C

# Hamiltonian and Eulerian Paths

## Introduction

The goal of this exercise is to explain and compute the Hamiltonian and Eulerian Paths.

## Explanation

Let's use a day-to-day example to explain the concepts of Eulerian and Hamiltonian paths and their connection through the line graph.

### Eulerian Path

Imagine you are taking a walk in your neighborhood and want to pass through every street exactly once and end up where you started. To do this, you need to ensure a few things:

Your neighborhood must be connected, meaning you can reach any street from any other street.
Most intersections (vertices) must have an even number of streets leading into them. However, it's okay if a couple of intersections have an odd number of streets, as long as you start and finish at one of them.
In this scenario, the streets represent edges, and the intersections represent vertices of a graph. Finding a path that fulfills these conditions is like finding an Eulerian path in your neighborhood.

### Hamiltonian Path

Now, let's consider a different situation. You have a list of locations you want to visit, like your favorite park, a coffee shop, and a library, and you want to visit each location exactly once and then return home. It's not as easy to determine if such a path exists because there are no specific rules like the Eulerian path conditions. This is similar to the Hamiltonian path problem, which can be quite challenging to solve in a general scenario.

### Connection through Line Graph

Now, let's connect these two concepts through the line graph. Imagine you create a new map of your neighborhood where streets are represented by points (vertices), and if two streets share an intersection, you draw an edge between the corresponding points in the map. This map is the line graph of your neighborhood.

If you find an Eulerian path on your neighborhood streets (the original graph), then, in the line graph, there will be a Hamiltonian path. This means the path you walked on the streets can be represented as a path through the points (vertices) in the line graph.

Conversely, if there is a Hamiltonian path in the line graph (the map of street connections), it implies that you can find an Eulerian path in your neighborhood streets. This is because the Hamiltonian path in the line graph corresponds to a specific route on your neighborhood streets.

So, the connection is like this: finding an Eulerian path in your neighborhood streets (original graph) is related to finding a Hamiltonian path in the map of street connections (line graph), and vice versa. The line graph helps to bridge the concepts of traversing edges in the original graph and visiting vertices in the derived graph, just as in our day-to-day example.

## Code

Illustration of this connection by building small random graphs with networkx and finding eulerian or hamiltonian paths in the obtained graphs / line graphs.

First, let's install NetworkX if you haven't already:
"""

pip install networkx

"""Now, let's create random graphs and their line graphs and find Eulerian and Hamiltonian paths in both of them.

"""

import networkx as nx
import random

def has_eulerian_path(G):
    if not nx.is_connected(G):
        return False
    odd_degree_count = sum(1 for node in G if G.degree(node) % 2 != 0)
    return odd_degree_count == 0 or odd_degree_count == 2

def has_hamiltonian_path(G):
    return nx.is_connected(G) and nx.is_eulerian(G.to_directed())

random.seed(0)
nodes = 6
edges = 8
G = nx.gnm_random_graph(nodes, edges)

L = nx.line_graph(G)

has_eulerian = has_eulerian_path(G)
has_hamiltonian = has_hamiltonian_path(G)
has_eulerian_line = has_eulerian_path(L)
has_hamiltonian_line = has_hamiltonian_path(L)

print("Original Graph:")
print(f"Has Eulerian Path: {has_eulerian}")
print(f"Has Hamiltonian Path: {has_hamiltonian}\n")

print("Line Graph:")
print(f"Has Eulerian Path: {has_eulerian_line}")
print(f"Has Hamiltonian Path: {has_hamiltonian_line}")

"""This code will create a random graph and its corresponding line graph. It will then check for the existence of Eulerian and Hamiltonian paths in both the original graph and the line graph. The results will indicate whether these paths exist in each graph.

Remember that for small random graphs, you might need to adjust the number of nodes and edges to control the presence of Eulerian and Hamiltonian paths. The random seed ensures reproducibility.

## Which one is considered as 'harder'

From an algorithmic point of view, the Hamiltonian Path problem is generally considered harder than the Eulerian Path problem. Here's why:

- Computational Complexity

The Eulerian Path problem can be solved in polynomial time for specific cases, such as when the graph is connected and satisfies the degree conditions (all vertices have even degrees, except for two with odd degrees). Algorithms like Hierholzer's algorithm can efficiently find an Eulerian path under these conditions.
In contrast, the Hamiltonian Path problem is NP-complete. This means there is no known algorithm that can solve it for all graphs in polynomial time, and it is believed to be computationally difficult.

- Algorithmic Approaches

Finding an Eulerian path typically involves simpler and more structured algorithms, which are often based on traversing the edges of the graph efficiently. These algorithms are well-defined and have polynomial time complexity for suitable cases.
The Hamiltonian Path problem lacks such efficient and structured algorithms for general cases. It involves exploring all possible paths through the graph, which can lead to an exponential number of possibilities, making it challenging to find a solution efficiently.

- Decision Complexity

In decision theory, it's known that the Hamiltonian Path problem is NP-complete. This implies that if you can find a polynomial-time algorithm to solve the Hamiltonian Path problem, you could also solve many other NP-complete problems in polynomial time. This is not the case for the Eulerian Path problem, which has specific conditions that make it easier to tackle.

## Conclusion

In summary, the Hamiltonian Path problem is considered harder from an algorithmic point of view because it lacks efficient algorithms for general cases, is NP-complete, and involves a more complex decision theory, while the Eulerian Path problem has specific conditions and structured algorithms that can be applied in polynomial time for those cases.
"""