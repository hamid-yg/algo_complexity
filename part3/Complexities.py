# -*- coding: utf-8 -*-
"""Part 3: Complexities.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z64YVkpqDDe54HjHIxR_k797MXyJPkCX

## Introduction

In this exercise, we will analyze the time complexity of two Python functions, function_1 and function_2. We will first provide an overview of the algorithms and then proceed to analyze their time complexity using measurements and curve fitting. This exercise will help us understand the computational efficiency of these functions.

## Detailed Algorithm Analysis

### Function 1

The outer loop runs from 0 to n^2 - 1, resulting in O(n^2) complexity.
The inner loop runs from 0 to i, where i ranges from 0 to n^2 - 1. The sum of this loop has a time complexity of O(n^4/2), which simplifies to O(n^4).
"""

def function_1(n: int) -> None:
    temp_list = list()
    for i in range(n**2):
        temp = 0
        for j in range(i):
            temp += j
        temp_list.append(temp)
    sum(temp_list)

"""### Function 2

The outer loop runs from 0 to n - 1, resulting in O(n) complexity.
Inside the loop, creating and shuffling a list of length n is typically O(n), and finding the maximum value is O(n).
"""

def function_2(n: int) -> None:
    print(n)
    for i in range(n):
        temp_list = [j+i for j in range(n)]
        shuffle(temp_list)
        max(temp_list)

"""## Technologies & Librairies used

### Installation

Before running the code for this exercise, you'll need to install the necessary tools and libraries.

You'll need to install the following Python libraries using pip:


"""

!pip install numpy
!pip install matplotlib

"""
## Code

Now, let's implement the code to measure the execution times and fit polynomials to verify the time complexity bounds.


"""

import time
import numpy as np
import matplotlib.pyplot as plt
from random import shuffle

n_values = [10, 20, 30, 40, 50]  # Adjust as needed
execution_times_1 = []
execution_times_2 = []

for n in n_values:
    start_time = time.time()
    function_1(n)
    execution_times_1.append(time.time() - start_time)

    start_time = time.time()
    function_2(n)
    execution_times_2.append(time.time() - start_time)

plt.figure()
plt.subplot(2, 1, 1)
plt.plot(n_values, execution_times_1, label='Function 1')
plt.title('Function 1 Execution Time')

plt.subplot(2, 1, 2)
plt.plot(n_values, execution_times_2, label='Function 2')
plt.title('Function 2 Execution Time')

degree_1 = 4
degree_2 = 1
coeffs_1 = np.polyfit(n_values, execution_times_1, degree_1)
coeffs_2 = np.polyfit(n_values, execution_times_2, degree_2)

plt.show()

print(f'Function 1 Polynomial Coefficients: {coeffs_1}')

print(f'Function 2 Polynomial Coefficients: {coeffs_2}')

"""## Conclusion

In this exercise, we successfully analyzed the time complexity of two Python functions, function_1 and function_2. We determined that function_1 has a time complexity of O(n^4) and function_2 has a time complexity of O(n). Our analysis was validated by measuring execution times and fitting polynomials to the data. Understanding the time complexity of algorithms is crucial for optimizing code and making informed decisions in algorithm selection for various applications.
"""